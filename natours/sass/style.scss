$color-primary: #55c57a;
$color-primary-light: #7ed56f;
$color-primary-dark: #28b485;

$color-grey-dark: #777;
$color-white: #FFF;
$color-black: #000;

/* all elements including synthetic psuedo elements */
*,
*::after,
*::before {
  margin: 0;
  padding: 0;
  /*
    inherited - ultimately from body.
    This is considered a better practice as a component and/or plugin can override the
    behaviour for an element. However to make this work we need to include pseudo elements
    in universal matcher
   */
  box-sizing: inherit;
}

html {
  /*
  Use 10 as font-size so that 1 rem is == 1rem and figuring out what you should
  change values to is easy as just divide by 10
  */
  /*font-size: 10px*/
;

  /*
   Instead of using fixed base font-size we can use a proportional size. That way if the user has increased the
   font-size (i.e. they are may have sight challenges) we are not overriding. Browsers normally have 16px as the
   default  font size and thus 100% == 16px and 62.5% == 10px.
   */
  font-size: 62.5%;
}

body {
  /*
  Everything related to inheritable font characteristics should be put
  in the body tag rather than the above universal selector. This is primarily
  for performance reasons as the universal selector applies everywhere but fonts
  only apply to elements below the body.
  */
  font-family: "Lato", sans-serif;
  font-weight: 400;
  line-height: 1.7;
  color: $color-grey-dark;

  /* white padding around entire web-page */
  padding: 3rem;
  box-sizing: border-box;
}

.header {
  /* 95% of the viewport height */
  height: 95vh;
  /*

    two background images.
    order is important
    first is gradient with alpha that colors the image that peaks through in second layer
    */
  /* background-image: linear-gradient(to right bottom, rgba(126, 213, 111, 0.8), rgba(40, 180, 131, 0.8)), url("../img/hero.jpg"); */
  /*
    The top of the image is anchored to the top of the .header.
  */
  /* background-position: top; */

  /* The other background properties can be optimized into the following. */
  background: linear-gradient(to right bottom, rgba($color-primary-light, 0.8), rgba($color-primary-dark, 0.8)), url(../img/hero.jpg) top;

  /** whatever the width of the element will try to fit image to size */
  background-size: cover;

  position: relative;

  /* This clips everything not contained in the polygon. This defines a polygon that cuts own triangle in bottom right corner */
  clip-path: polygon(0 0, 100% 0, 100% 75vh, 0 100%);
}

.header__logo-box {
  position: absolute;
  left: 4rem;
  top: 4rem;
}

.header__logo {
  height: 3.5rem;
}

.header__text-box {
  position: absolute;
  top: 40%;
  left: 50%;
  transform: translate(-50%, -50%);
  text-align: center;
}

.heading-primary {
  color: $color-white;
  /* Make sure all text is uppercase */
  text-transform: uppercase;

  margin-bottom: 6rem;

  /* this stops the shake at the end of the animation */
  backface-visibility: hidden;
}

.heading-primary--main {
  display: block;
  font-size: 6rem;
  font-weight: 400;
  letter-spacing: 3.5rem;
  padding-left: 3.5rem;
  text-align: center;
  animation-name: moveInLeft;
  /* runs animation for this amount of time */
  animation-duration: 1s;
  animation-timing-function: ease-out;
}

.heading-primary--sub {
  display: block;
  font-size: 2rem;
  font-weight: 700;
  letter-spacing: 1.74rem;
  padding-left: 1.74rem;
  text-align: center;
  animation-name: moveInRight;
  animation-duration: 1s;
  animation-timing-function: ease-out;
}

@keyframes moveInLeft {
  0% {
    opacity: 0;
    transform: translateX(-10rem);
  }
  80% {
    transform: translateX(1rem);
  }
  100% {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes moveInRight {
  0% {
    opacity: 0;
    transform: translateX(10rem);
  }
  80% {
    transform: translateX(-1rem);
  }
  100% {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes moveInButton {
  0% {
    opacity: 0;
    transform: translateY(3rem);
  }
  100% {
    opacity: 1;
    transform: translateY(0);
  }
}

/*
link is the special pseudo class available on <a/> class as is visited:
*/
.button:link, .button:visited {
  display: inline-block;
  text-transform: uppercase;
  text-decoration: none;
  padding: 1.5rem 4rem;
  border-radius: 10rem;
  font-size: 1.6em;
  /*
    This transition smooths the state transition for :hover and :active state.
    So translations are transitioned to and from
   */
  transition: all 0.2s;

  /* Require this relative as the :after psuedo element has absolute position which searches up parents till it finds relative */
  position: relative;
}

.button--animated {
  animation-name: moveInButton;
  animation-duration: 0.5s;
  animation-delay: 0.75s;
  animation-timing-function: ease-in-out;

  /*
   This applies the 0% animation properties before the animation starts
   */
  animation-fill-mode: backwards;
}

.button:hover {
  transform: translateY(-0.3rem);

  box-shadow: /* x */
    0 /* y */
    1rem /* blur */
    2rem /* alpha value */
    rgba($color-black, .2);
}

/* :active indicates when button is clicked */
.button:active {
  transform: translateY(-0.1rem);
  /*
  The shadow seems closer and less blurry compared to hover

  This gives the user the feel that pressed button and it got closer to page so materialistic interaction
  */

  box-shadow: /* x */
    0 /* y */
    0.5rem /* blur */
    1rem /* alpha value */
    rgba($color-black, .2);
}

.button--white {
  background-color: $color-white;
  color: $color-grey-dark;
}

.button::after {
  /* The :after pseudo element has to have both a content and a display if you want it to display */
  content: "";
  /* It is inline-block because .button is alos an inline-block */
  display: inline-block;

  /*
  The :after psuedo element is treated like a child element so these 100% measures
  indicate it should be the same size as the container element.
  */
  height: 100%;
  width: 100%;
  border-radius: 10rem;

  transition: all 0.4s;

  /* These next properties put it directly under the existing element */
  position: absolute;
  top: 0;
  left: 0;

  z-index: -1;
}

.button--white::after {
  background-color: $color-white;
}

.button:hover::after {
  transform: scaleX(1.4) scaleY(1.6);
  opacity: 0;
}
